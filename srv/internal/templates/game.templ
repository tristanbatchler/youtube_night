package templates

import (
	"fmt"
	"github.com/tristanbatchler/youtube_night/srv/internal/db"
	"github.com/tristanbatchler/youtube_night/srv/internal/states"
	"github.com/tristanbatchler/youtube_night/srv/internal/stores"
	"github.com/tristanbatchler/youtube_night/srv/internal/util"
)

templ mediaPlayer(video db.Video) {
	<media-player
		id="yt-player"
		title={ video.Title }
		preload
		playsinline
		crossorigin
		muted
		load="play"
		autoplay
		src={ fmt.Sprintf("youtube/%s", video.VideoID) }
	>
		<media-provider></media-provider>
		<media-video-layout thumbnails={ video.ThumbnailUrl }></media-video-layout>
	</media-player>
	<script>
		// Setup event handlers for the video player
		document.addEventListener('DOMContentLoaded', function() {
			const player = document.getElementById('yt-player');
			if (!player) {
				return;
			}

			const isHost = Boolean(document.getElementById('host-controls'));
			player.dataset.hostPaused = player.dataset.hostPaused || 'false';
			player.dataset.lastHostTimestamp = player.dataset.lastHostTimestamp || '0';

			const resolveMedia = () => {
				const provider = player.querySelector('media-provider');
				if (provider && provider.media) {
					return provider.media;
				}
				return player;
			};

			const currentHostTime = () => {
				const media = resolveMedia();
				if (media && typeof media.currentTime === 'number') {
					return Math.max(0, media.currentTime);
				}
				return Math.max(0, player.currentTime || 0);
			};

			let lastAction = '';
			let lastTimestamp = -1;
			let lastPaused = false;
			const epsilon = 0.15;

			const sendPlaybackUpdate = (action, pausedState) => {
				const timestamp = currentHostTime();
				if (lastAction === action && lastPaused === pausedState && Math.abs(timestamp - lastTimestamp) < epsilon) {
					return;
				}

				lastAction = action;
				lastPaused = pausedState;
				lastTimestamp = timestamp;
				player.dataset.lastHostTimestamp = timestamp.toString();
				player.dataset.hostPaused = pausedState ? 'true' : 'false';

				fetch('/game/playback-state', {
					method: 'POST',
					credentials: 'same-origin',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ action, timestamp, isPaused: pausedState })
				}).catch(err => {
					console.error('Failed to send playback state update:', err);
				});
			};

			player.__sendPlaybackUpdate = sendPlaybackUpdate;

			if (isHost) {
				player.addEventListener('play', () => sendPlaybackUpdate('play', false));
				player.addEventListener('pause', () => sendPlaybackUpdate('pause', true));
				player.addEventListener('seeked', () => {
					const timestamp = currentHostTime();
					if (Math.abs(timestamp - lastTimestamp) > epsilon) {
						sendPlaybackUpdate('seek', player.paused);
					}
				});
			} else {
				const layout = player.querySelector('media-video-layout');
				if (layout) {
					layout.style.pointerEvents = 'none';
				}

				player.addEventListener('keydown', event => {
					const blockedKeys = [' ', 'k', 'j', 'l'];
					if (blockedKeys.includes(event.key.toLowerCase())) {
						event.preventDefault();
					}
				});

				player.addEventListener('play', event => {
					if (player.dataset.hostPaused === 'true') {
						event.preventDefault();
						pauseVideo(Number(player.dataset.lastHostTimestamp || 0));
					}
				});

				player.addEventListener('pause', event => {
					if (player.dataset.hostPaused !== 'true') {
						event.preventDefault();
						const hostTimestamp = Number(player.dataset.lastHostTimestamp || 0);
						syncVideoToHost(player, hostTimestamp, true);
					}
				});

				player.addEventListener('seeking', event => {
					const hostTimestamp = Number(player.dataset.lastHostTimestamp || 0);
					const media = resolveMedia();
					const current = media && typeof media.currentTime === 'number' ? media.currentTime : player.currentTime;
					if (Math.abs(Number(current || 0) - hostTimestamp) > 0.25) {
						event.preventDefault();
						syncVideoToHost(player, hostTimestamp, player.dataset.hostPaused !== 'true');
					}
				});
			}
		});
		
		// Expose a function to seek to a specific time
		window.seekVideoTo = function(seconds) {
			const player = document.getElementById('yt-player');
			if (player) {
				try {
					setPlayerCurrentTime(player, seconds);
					if (player.__sendPlaybackUpdate) {
						const pausedState = player.dataset.hostPaused === 'true';
						player.__sendPlaybackUpdate('seek', pausedState);
					}
				} catch (err) {
					console.warn('Failed to seek to timestamp:', err);
				}
			}
		}
	</script>
}

templ gameContents(gameState *states.GameState, sessionData *stores.SessionData) {
	{{ videos := gameState.Videos }}
	<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
		@dashboardHeader(sessionData)
		<div class="grid grid-cols-1 gap-6">
			<!-- Main player section -->
			<div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
				<div class="flex justify-between items-center mb-4">
					<h2 class="text-xl font-semibold text-gray-900 dark:text-white">Now Playing</h2>
					if sessionData.IsHost {
						<div id="host-controls" class="flex items-center space-x-2">
							<button
								id="stop-game-btn"
								class="px-3 py-1 bg-red-600 hover:bg-red-700 text-white rounded-md shadow transition-colors"
								hx-post="/game/stop"
								hx-swap="none"
							>
								End Game Session
							</button>
						</div>
					}
				</div>
				// Currently playing
				<div id="current-video-info" class="mt-4 border-t border-gray-200 dark:border-gray-700 pt-4">
					<h3 id="current-video-title" class="font-medium text-lg text-gray-900 dark:text-white">
						if len(videos) > 0 {
							{ videos[0].Title }
						} else {
							No videos available
						}
					</h3>
					<p id="current-video-channel" class="text-sm text-gray-600 dark:text-gray-400">
						if len(videos) > 0 {
							{ videos[0].ChannelName }
						}
					</p>
				</div>
				// The actual player
				<div class="aspect-video w-full bg-black">
					@mediaPlayer(videos[0])
				</div>
				<!-- Guessing section - who submitted this video? -->
				<div class="mt-6 border-t border-gray-200 dark:border-gray-700 pt-4">
					<h3 class="text-lg font-medium text-gray-900 dark:text-white mb-3">Who submitted this video?</h3>
					<!-- Get the current video ID and index -->
					<div id="current-video-index-container" class="hidden" data-current-index="0"></div>
					<div id="current-video-id-container" class="hidden" data-video-id={ videos[0].VideoID }></div>
					<div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
						<!-- Show all gang members to pick from, but don't allow voting for yourself -->
						for _, member := range gameState.GangMembers {
							if member.ID != sessionData.UserId {
								<button
									id={ fmt.Sprintf("guess-user-%d", member.ID) }
									class="guess-user-btn flex items-center p-2 rounded-md border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
									hx-get={ fmt.Sprintf("/game/submit-guess?videoId=%s&guessedUserId=%d", videos[0].VideoID, member.ID) }
									hx-target="#current-guess-display"
									hx-swap="innerHTML"
									data-user-id={ fmt.Sprint(member.ID) }
									onclick="window.applyGuessHighlight(this)"
								>
									<span class="text-xl mr-2">{ util.AvatarTextToEmoji(member.AvatarPath.String) }</span>
									<span class="font-medium">{ member.Name }</span>
								</button>
							}
						}
					</div>
					<!-- Show the current guess for this video if it exists -->
					<div
						id="current-guess-display"
						class="mt-4 text-gray-700 dark:text-gray-300"
						hx-get={ fmt.Sprintf("/game/get-current-guess?videoId=%s", videos[0].VideoID) }
						hx-trigger="load"
						hx-swap="innerHTML"
					>
						@LoadingGuessDisplay()
					</div>
					<!-- For the host - reveal panel -->
					if sessionData.IsHost {
						<div id="host-reveal-panel" class="mt-6 bg-gray-100 dark:bg-gray-700 p-4 rounded-lg">
							<h3 class="text-lg font-medium text-gray-900 dark:text-white mb-2">Host Controls</h3>
							<div class="flex items-center space-x-4">
								<!-- Show the actual submitter -->
								<div
									id="actual-submitter-display"
									hx-get={ fmt.Sprintf("/game/get-submitter?videoId=%s", videos[0].VideoID) }
									hx-trigger="load"
									hx-swap="outerHTML"
								>
									@NoSubmitterDisplay()
								</div>
								<!-- Button to reveal guesses -->
								<button
									id="reveal-guesses-btn"
									class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-md transition-colors"
									hx-get={ fmt.Sprintf("/game/get-guesses?videoId=%s", videos[0].VideoID) }
									hx-target="#guesses-reveal-area"
									hx-swap="innerHTML"
								>
									Reveal All Guesses
								</button>
							</div>
							<!-- Guesses reveal area, initially hidden -->
							<div id="guesses-reveal-area" class="mt-3 hidden">
								<!-- This will be populated via HTMX -->
							</div>
						</div>
					}
				</div>
				// Video controls - only visible to host
				<div class="flex justify-between items-center mt-4">
					<div class="flex items-center space-x-3">
						if sessionData.IsHost {
							<button
								id="prev-video"
								class="px-3 py-1 bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 rounded-md transition-colors"
								_={ "on click\n" + 
									// Get the current index (1-based for display)
									"set displayIndex to parseInt(#current-video-index.textContent)\n" + 
									"set totalVideos to parseInt(#total-videos.textContent)\n" + 

									// Calculate new display index with wrap-around
									"if displayIndex <= 1\n" + 
									"	set newDisplayIndex to totalVideos\n" + 
									"else\n" + 
									"	set newDisplayIndex to displayIndex - 1\n" + 
									"end\n" + 

									// Convert to zero-based index for data access
									"set queueIndex to newDisplayIndex - 1\n" + 

									// Find the queue item
									"set targetItem to document.querySelector(`.video-queue-item[data-index=\"${queueIndex}\"]`)\n" + 

									"if targetItem\n" + 
									"	set videoId to targetItem.dataset.videoId\n" + 
									"	set videoTitle to targetItem.dataset.title\n" + 
									"	set videoChannel to targetItem.dataset.channel\n" + 

									// Update local player
									"	set #yt-player's src to `youtube/${videoId}`\n" + 
									"	set #current-video-title's textContent to videoTitle\n" + 
									"	set #current-video-channel's textContent to videoChannel\n" + 
									"	set #current-video-index's textContent to newDisplayIndex\n" + 

									// Reset guesses UI
									"	call resetGuessesUI(videoId, queueIndex)\n" + 

									// Send websocket message to update all clients - pass the queue index (0-based)
									"	fetch `/game/change-video?videoId=${videoId}&index=${queueIndex}`\n" + 
									"end" }
							>
								Previous
							</button>
							<button
								id="next-video"
								class="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors"
								_={ "on click\n" + 
									// Get the current index (1-based for display)
									"set displayIndex to parseInt(#current-video-index.textContent)\n" + 
									"set totalVideos to parseInt(#total-videos.textContent)\n" + 

									// Calculate new display index with wrap-around
									"if displayIndex >= totalVideos\n" + 
									"	set newDisplayIndex to 1\n" + 
									"else\n" + 
									"	set newDisplayIndex to displayIndex + 1\n" + 
									"end\n" + 

									// Convert to zero-based index for data access
									"set queueIndex to newDisplayIndex - 1\n" + 

									// Find the queue item
									"set targetItem to document.querySelector(`.video-queue-item[data-index=\"${queueIndex}\"]`)\n" + 

									"if targetItem\n" + 
									"	set videoId to targetItem.dataset.videoId\n" + 
									"	set videoTitle to targetItem.dataset.title\n" + 
									"	set videoChannel to targetItem.dataset.channel\n" + 

									// Update local player
									"	set #yt-player's src to `youtube/${videoId}`\n" + 
									"	set #current-video-title's textContent to videoTitle\n" + 
									"	set #current-video-channel's textContent to videoChannel\n" + 
									"	set #current-video-index's textContent to newDisplayIndex\n" + 

									// Reset guesses UI
									"	call resetGuessesUI(videoId, queueIndex)\n" + 

									// Send websocket message to update all clients - pass the queue index (0-based)
									"	fetch `/game/change-video?videoId=${videoId}&index=${queueIndex}`\n" + 
									"end" }
							>
								Next Video
							</button>
						} else {
							<div class="text-sm italic text-gray-500 dark:text-gray-400">
								Only the host can navigate videos
							</div>
						}
					</div>
					<div class="text-sm text-gray-700 dark:text-gray-300">
						<span id="current-video-index">1</span>/<span id="total-videos">{ fmt.Sprint(len(videos)) }</span>
					</div>
				</div>
			</div>
			<!-- Video queue section -->
			<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6">
				<div class="flex justify-between items-center mb-4">
					<h2 class="text-xl font-semibold text-gray-900 dark:text-white">Queue</h2>
					if len(videos) > 0 {
						@videoCountBadge(len(videos))
					}
				</div>
				<!-- Queue carousel -->
				<div class="overflow-x-auto pb-2">
					<div id="video-queue" class="flex space-x-4">
						for i, video := range videos {
							<div
								class={ fmt.Sprintf("video-queue-item flex-shrink-0 w-64 bg-gray-100 dark:bg-gray-700 rounded-md overflow-hidden %s", util.If(sessionData.IsHost, "cursor-pointer hover:ring-2 hover:ring-blue-500 transition-all", "")) }
								data-video-id={ video.VideoID }
								data-index={ fmt.Sprint(i) }
								data-title={ video.Title }
								data-channel={ video.ChannelName }
								_={ util.If(sessionData.IsHost, 
										"on click\n" +
										// Set queue index (0-based) from the clicked item
										"set queueIndex to my.dataset.index\n" +
										// Calculate display index (1-based) for the UI
										"set displayIndex to parseInt(queueIndex) + 1\n" +
										
										// Update local player
										"set #yt-player's src to `youtube/${my.dataset.videoId}`\n" + 
										"set #current-video-title's textContent to my.dataset.title\n" + 
										"set #current-video-channel's textContent to my.dataset.channel\n" + 
										"set #current-video-index's textContent to displayIndex\n" + 
										
										// Reset guesses UI
										"call resetGuessesUI(my.dataset.videoId, queueIndex)\n" + 
										
										// Send websocket message to update all clients - pass the queue index (0-based)
										"fetch `/game/change-video?videoId=${my.dataset.videoId}&index=${queueIndex}`",
									"") }
							>
								<div class="aspect-video bg-gray-200 dark:bg-gray-800 relative">
									if video.ThumbnailUrl != "" {
										<img src={ video.ThumbnailUrl } alt="Video thumbnail" class="w-full h-full object-cover"/>
									}
									if sessionData.IsHost {
										<div class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-40 opacity-0 hover:opacity-100 transition-opacity">
											<div class="w-12 h-12 rounded-full bg-white bg-opacity-80 flex items-center justify-center">
												<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-black" fill="none" viewBox="0 0 24 24" stroke="currentColor">
													<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path>
												</svg>
											</div>
										</div>
									}
								</div>
								<div class="p-2">
									<h4 class="text-sm font-medium text-gray-900 dark:text-white line-clamp-1">{ video.Title }</h4>
									<p class="text-xs text-gray-600 dark:text-gray-400">{ video.ChannelName }</p>
								</div>
							</div>
						}
					</div>
				</div>
			</div>
		</div>
	</div>
	<script>
		const GUESS_HIGHLIGHT_CLASSES = ['ring-2', 'ring-blue-500', 'bg-blue-50', 'dark:bg-blue-900/20'];

		window.applyGuessHighlight = function(button) {
			const buttons = document.querySelectorAll('.guess-user-btn');
			buttons.forEach(btn => {
				btn.classList.remove(...GUESS_HIGHLIGHT_CLASSES);
			});
			if (button) {
				button.classList.add(...GUESS_HIGHLIGHT_CLASSES);
			}
		};

		window.highlightGuessByUserId = function(userId) {
			if (!userId) {
				window.applyGuessHighlight(null);
				return;
			}
			const button = document.querySelector(`.guess-user-btn[data-user-id="${userId}"]`);
			if (button) {
				window.applyGuessHighlight(button);
			}
		};

		// Function to reset the guesses UI for a new video
		function resetGuessesUI(videoId, videoIndex) {
			// Reset all guess buttons
			document.querySelectorAll('.guess-user-btn').forEach(btn => {
				btn.classList.remove(...GUESS_HIGHLIGHT_CLASSES);
				
				// Update the hx-get attribute for the buttons
				const userId = btn.getAttribute('data-user-id') || btn.id.replace('guess-user-', '');
				btn.setAttribute('hx-get', `/game/submit-guess?videoId=${videoId}&guessedUserId=${userId}`);
			});
			window.applyGuessHighlight(null);
			
			// Reset host reveal panel if present
			if (document.getElementById('host-reveal-panel')) {
				// Update submitter info
				const submitterDisplay = document.getElementById('actual-submitter-display');
				submitterDisplay.setAttribute('hx-get', `/game/get-submitter?videoId=${videoId}`);
				htmx.process(submitterDisplay);
				
				// Reset reveal button
				const revealBtn = document.getElementById('reveal-guesses-btn');
				revealBtn.setAttribute('hx-get', `/game/get-guesses?videoId=${videoId}`);
				revealBtn.disabled = false;
				revealBtn.classList.remove('opacity-50', 'cursor-not-allowed');
				revealBtn.textContent = 'Reveal All Guesses';
				
				// Hide guesses area
				const revealArea = document.getElementById('guesses-reveal-area');
				revealArea.classList.add('hidden');
				revealArea.classList.remove('block');
				revealArea.innerHTML = '';
			}
			
			// Reset current guess display and trigger a fetch for the new video
			const display = document.getElementById('current-guess-display');
			display.innerHTML = '<p>Loading your guess...</p>';
			display.setAttribute('hx-get', `/game/get-current-guess?videoId=${videoId}`);
			htmx.process(display);
		}

		// Update guessing interface when video changes
		document.addEventListener('DOMContentLoaded', function() {
			// Watch for video changes via mutations to the player
			const observer = new MutationObserver(mutations => {
				// Reset the guessing UI when video source changes
				const currentVideoIdContainer = document.getElementById('current-video-id-container');
				const newVideoId = document.querySelector('#yt-player').src.split('/').pop();
				const indexDisplay = document.getElementById('current-video-index');
				
				if (currentVideoIdContainer.getAttribute('data-video-id') !== newVideoId) {
					// Update the video ID in our container
					currentVideoIdContainer.setAttribute('data-video-id', newVideoId);
					
					// Update video index
					const videoIndex = parseInt(indexDisplay.textContent) - 1; // Convert 1-based to 0-based
					document.getElementById('current-video-index-container').setAttribute('data-current-index', videoIndex.toString());
					
					// Reset all UI elements for guesses
					resetGuessesUI(newVideoId, videoIndex);
				}
			});
			
			// Observe the player for src changes
			const player = document.querySelector('#yt-player');
			if (player) {
				observer.observe(player, { attributes: true, attributeFilter: ['src'] });
			}
		});

		document.body.addEventListener('htmx:afterSwap', function(event) {
			if (event.target && event.target.id === 'current-guess-display') {
				const container = event.target.querySelector('[data-guess-user-id]');
				if (container) {
					window.highlightGuessByUserId(container.getAttribute('data-guess-user-id'));
				} else {
					window.applyGuessHighlight(null);
				}
			} else if (event.target && event.target.id === 'guesses-reveal-area') {
				event.target.classList.remove('hidden');
				event.target.classList.add('block');
				const revealBtn = document.getElementById('reveal-guesses-btn');
				if (revealBtn) {
					revealBtn.disabled = true;
					revealBtn.classList.add('opacity-50', 'cursor-not-allowed');
					revealBtn.textContent = 'Guesses Revealed';
				}
			}
		});
	</script>
}

templ Game(gameState *states.GameState, sessionData *stores.SessionData) {
	@MainContent(gameContents(gameState, sessionData))
}
